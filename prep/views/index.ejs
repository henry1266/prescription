<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>è™•æ–¹æ¸…å–®</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

    <h2>ğŸ“… ç¯©é¸æ—¥æœŸç¯„åœ</h2>
    <label for="startDate">èµ·å§‹æ—¥æœŸï¼š</label>
    <input type="date" id="startDate">
    <label for="endDate">çµæŸæ—¥æœŸï¼š</label>
    <input type="date" id="endDate">
    <button onclick="filterByDate()">ç¯©é¸</button>
	
	<h2>ğŸ“ˆ æ¯æ—¥æœ‰æ•ˆè™•æ–¹ç­†æ•¸ï¼ˆå¤šç·šæŠ˜ç·šåœ–ï¼‰</h2>
    <canvas id="calendarChart" width="600" height="230"></canvas>



<h1>è™•æ–¹æ¸…å–®</h1>

    <table border="1">
        <thead>
            <tr>
                <th>PID</th>
                <th>è™•æ–¹æ—¥æœŸ</th>
                <th>å¤©æ•¸</th>
                <th>æ¬¡æ•¸</th>
            </tr>
        </thead>
        <tbody>
            <% notes.forEach(note => { %>
                <tr>
                    <td><%= note.pid %></td>
                    <td><%= note.predate %></td>
                    <td><%= note.preday %></td>
                    <td><%= note.precount %></td>
                </tr>
            <% }); %>
        </tbody>
    </table>

    <h2>ğŸ“… æ¯æ—¥æœ‰æ•ˆè™•æ–¹ç­†æ•¸</h2>
    <table border="1">
        <thead>
            <tr>
                <th>æ—¥æœŸ</th>
                <th>æœ‰æ•ˆè™•æ–¹ç­†æ•¸</th>
            </tr>
        </thead>
        <tbody id="calendar-table-body">
            <% calendar.forEach(entry => { %>
                <tr>
                    <td><%= entry.date %></td>
                    <td><%= entry.count %></td>
                </tr>
            <% }); %>
        </tbody>
    </table>


<script>
const calendarData = <%- JSON.stringify(calendar) %>;

// åŸå§‹è³‡æ–™
const labels = calendarData.map(entry => entry.date);
const rawData = calendarData.map(entry => entry.count);

// è¨ˆç®—ç§»å‹•å¹³å‡
function movingAverage(data, windowSize = 7) {
    const result = [];
    for (let i = 0; i < data.length; i++) {
        if (i < windowSize - 1) {
            result.push(null); // ä¸è¶³ä»¥ç”¢ç”Ÿç§»å‹•å¹³å‡
        } else {
            const subset = data.slice(i - windowSize + 1, i + 1);
            const avg = subset.reduce((a, b) => a + b, 0) / windowSize;
            result.push(avg);
        }
    }
    return result;
}



// å±€éƒ¨æ–œç‡ï¼ˆæ¯ 7 å¤©ä¸€æ®µï¼‰
function rollingSlope(data, windowSize = 7) {
    const result = Array(data.length).fill(null);
    for (let i = 0; i <= data.length - windowSize; i++) {
        const x = Array.from({ length: windowSize }, (_, k) => k);
        const y = data.slice(i, i + windowSize);
        const meanX = x.reduce((a, b) => a + b) / windowSize;
        const meanY = y.reduce((a, b) => a + b) / windowSize;
        let num = 0, den = 0;
        for (let k = 0; k < windowSize; k++) {
            num += (x[k] - meanX) * (y[k] - meanY);
            den += (x[k] - meanX) ** 2;
        }
        const slope = den === 0 ? 0 : num / den;
        result[i + Math.floor(windowSize / 2)] = slope;
    }
    return result;
}

// å»ºç«‹åœ–è¡¨
const ctx = document.getElementById('calendarChart').getContext('2d');
const chart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: labels,
        datasets: [
    {
        label: 'å€åŸŸé¡è‰²ä¾æ–œç‡è®ŠåŒ–',
        data: rawData,
        borderColor: 'transparent',
        backgroundColor: 'rgba(0,0,0,0.05)',
        fill: true,
        pointRadius: 0,
        segment: {
            backgroundColor: ctx => {
                const index = ctx.p1DataIndex;
                const slopeValue = rollingSlope(rawData)[index];
                if (slopeValue > 0) return 'rgba(0, 128, 0, 0.2)';
                if (slopeValue < 0) return 'rgba(255, 0, 0, 0.2)';
                return 'rgba(128, 128, 128, 0.2)';
            }
        },
        hidden: false
    },
    {
        label: 'åŸå§‹è³‡æ–™',
        data: rawData,
        borderColor: 'blue',
        backgroundColor: 'rgba(0, 0, 255, 0.1)',
        fill: false,
        hidden: false
    },
    {
        label: '7æ—¥ç§»å‹•å¹³å‡',
        data: movingAverage(rawData),
        borderColor: 'green',
        backgroundColor: 'rgba(0, 128, 0, 0.1)',
        fill: false,
        hidden: false
    },
    {
        label: '7æ—¥å±€éƒ¨æ–œç‡',
        data: rollingSlope(rawData),
        fill: false,
        hidden: false,
        segment: {
            borderColor: ctx => {
                const value = ctx.p1.parsed.y;
                if (value > 0) return 'green';
                if (value < 0) return 'red';
                return 'gray';
            }
        },
        borderWidth: 2,
        pointRadius: 3,
    }
]
    },
    options: {
        scales: {
            y: {
                beginAtZero: true,
                title: { display: true, text: 'æœ‰æ•ˆè™•æ–¹ç­†æ•¸' }
            },
            y2: {
                beginAtZero: true,
                title: { display: true, text: 'æˆé•·ç‡ (%)' },
                position: 'right',
                grid: { drawOnChartArea: false }
            },
            x: {
                title: { display: true, text: 'æ—¥æœŸ' }
            }
        },
        plugins: {
            legend: { display: true },
            tooltip: { mode: 'index', intersect: false }
        }
    }
});

// å‹¾é¸æ§åˆ¶
function toggleDataset(index) {
    chart.data.datasets[index].hidden = !chart.data.datasets[index].hidden;
    chart.update();
}

function filterByDate() {
            const start = new Date(document.getElementById('startDate').value);
            const end = new Date(document.getElementById('endDate').value);

            const filtered = calendarData.filter(entry => {
                const current = new Date(entry.date);
                return (!isNaN(start) ? current >= start : true) &&
                       (!isNaN(end) ? current <= end : true);
            });

            const newLabels = filtered.map(entry => entry.date);
            const newData = filtered.map(entry => entry.count);

            chart.data.labels = newLabels;
            chart.data.datasets[0].data = newData;
            chart.update();

            const slope = calculateSlope(newLabels, newData);
            document.getElementById('slopeOutput').innerText = `æ–œç‡ï¼š${slope.toFixed(4)}`;

            // æ›´æ–°è¡¨æ ¼è³‡æ–™ï¼ˆå¯é¸ï¼‰
            const tableBody = document.getElementById('calendar-table-body');
            tableBody.innerHTML = '';
            filtered.forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${entry.date}</td><td>${entry.count}</td>`;
                tableBody.appendChild(row);
            });
        }
// é è¨­è‡ªå‹•ç¯©é¸ï¼šå¾æœ€æ—©æ—¥æœŸåˆ°ä»Šå¤©
window.addEventListener('DOMContentLoaded', () => {
    document.getElementById('startDate').value = calendarData[0]?.date;
    document.getElementById('endDate').value = new Date().toISOString().split("T")[0];
    filterByDate(); // é è¨­ç¯„åœåˆå§‹åŒ–
});
</script>
</body>
</html>
