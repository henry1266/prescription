<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>è™•æ–¹åœ–è¡¨åˆ†æ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        h1, h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
        table { border-collapse: collapse; margin-top: 15px; width: auto; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        button { padding: 8px 15px; cursor: pointer; }
        #completed-pids-container { margin-top: 20px; padding: 15px; border: 1px solid #e0e0e0; background-color: #f9f9f9; }
        #completed-pids-list { margin-top: 10px; }
        #completed-pids-list table { width: 100%; } /* Make table full width of container */
        .error-message { color: red; font-weight: bold; }
    </style>
</head>
<body>

    <h1>è™•æ–¹åˆ†æå„€è¡¨æ¿</h1>

    <h2>ğŸ“… ç¯©é¸æ—¥æœŸç¯„åœ (åœ–è¡¨èˆ‡ä¸‹æ–¹è¡¨æ ¼å°‡é€£å‹•)</h2>
    <label for="startDate">èµ·å§‹æ—¥æœŸï¼š</label>
    <input type="date" id="startDate">
    <label for="endDate">çµæŸæ—¥æœŸï¼š</label>
    <input type="date" id="endDate">
    <button onclick="applyFilters()">ç¯©é¸</button>

    <h2>ğŸ“ˆ æ¯æ—¥æœ‰æ•ˆè™•æ–¹ç­†æ•¸ï¼ˆå¤šç·šæŠ˜ç·šåœ–ï¼‰</h2>
    <div style="position: relative; height:550px; width:100%">
        <canvas id="calendarChart"></canvas>
    </div>
    
    <div id="completed-pids-container">
        <h2>ğŸ“Œ ç¯©é¸æœŸé–“å…§åˆ°æœŸä¸”ç‚ºæœ€å¾Œè™•æ–¹çš„è¨˜éŒ„</h2>
        <div id="completed-pids-list">è«‹é»æ“Šã€Œç¯©é¸ã€æŒ‰éˆ•ä»¥æŸ¥è©¢ã€‚</div>
        <div id="completed-pids-error" class="error-message" style="display: none;"></div>
    </div>



    <h2>ğŸ“‹ åŸå§‹è™•æ–¹æ¸…å–® (Pretype 04)</h2>
    <table border="1">
        <thead>
            <tr>
                <th>PID</th>
                <th>è™•æ–¹æ—¥æœŸ (YYYYMMDD)</th>
                <th>å¤©æ•¸</th>
                <th>æ¬¡æ•¸</th>
            </tr>
        </thead>
        <tbody>
            <% if (typeof notes !== 'undefined' && notes.length > 0) { %>
                <% notes.forEach(note => { %>
                    <tr>
                        <td><%= note.pid %></td>
                        <td><%= note.predate %></td>
                        <td><%= note.preday %></td>
                        <td><%= note.precount %></td>
                    </tr>
                <% }); %>
            <% } else { %>
                <tr><td colspan="4">ç„¡è™•æ–¹è³‡æ–™ã€‚</td></tr>
            <% } %>
        </tbody>
    </table>

    <h2>ğŸ“… æ¯æ—¥æœ‰æ•ˆè™•æ–¹ç­†æ•¸çµ±è¨ˆ (æ ¹æ“šä¸Šæ–¹æ—¥æœŸç¯©é¸)</h2>
    <table border="1">
        <thead>
            <tr>
                <th>æ—¥æœŸ (YYYY-MM-DD)</th>
                <th>æœ‰æ•ˆè™•æ–¹ç­†æ•¸</th>
            </tr>
        </thead>
        <tbody id="calendar-table-body">
            <% if (typeof calendar !== 'undefined' && calendar.length > 0) { %>
                <% calendar.forEach(entry => { %>
                    <tr>
                        <td><%= entry.date %></td>
                        <td><%= entry.count %></td>
                    </tr>
                <% }); %>
            <% } else { %>
                <tr><td colspan="2">ç„¡æ—¥æ›†è³‡æ–™ã€‚</td></tr>
            <% } %>
        </tbody>
    </table>

<script>
const calendarData = <%- typeof calendar !== 'undefined' ? JSON.stringify(calendar) : '[]' %>;
const initialNotes = <%- typeof notes !== 'undefined' ? JSON.stringify(notes) : '[]' %>;

// --- Chart Data Preparation ---
console.log("Calendar Data for Chart:", calendarData);
let labels = calendarData.map(entry => entry.date);
let rawData = calendarData.map(entry => entry.count);
console.log("Chart Labels:", labels);
console.log("Chart Raw Data:", rawData);

// --- Chart Helper Functions (Moving Average, Rolling Slope) ---
function movingAverage(data, windowSize = 7) {
    const result = [];
    if (!data || data.length === 0) return result;
    for (let i = 0; i < data.length; i++) {
        if (i < windowSize - 1) {
            result.push(null);
        } else {
            const subset = data.slice(i - windowSize + 1, i + 1);
            const sum = subset.reduce((a, b) => (a || 0) + (b || 0), 0);
            result.push(sum / windowSize);
        }
    }
    return result;
}

function rollingSlope(data, windowSize = 7) {
    const result = Array(data?.length || 0).fill(null);
     if (!data || data.length < windowSize) return result;
    for (let i = 0; i <= data.length - windowSize; i++) {
        const x = Array.from({ length: windowSize }, (_, k) => k);
        const y = data.slice(i, i + windowSize);
        if (y.some(val => typeof val !== 'number' || isNaN(val))) continue;

        const meanX = (windowSize - 1) / 2;
        const meanY = y.reduce((a, b) => a + b, 0) / windowSize;
        let num = 0, den = 0;
        for (let k = 0; k < windowSize; k++) {
            num += (x[k] - meanX) * (y[k] - meanY);
            den += (x[k] - meanX) ** 2;
        }
        const slope = den === 0 ? 0 : num / den;
        result[i + Math.floor(windowSize / 2)] = slope;
    }
    return result;
}

// --- Chart Initialization ---
let chart;
const ctx = document.getElementById('calendarChart')?.getContext('2d');
if (ctx) {
    chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'å€åŸŸé¡è‰²ä¾æ–œç‡è®ŠåŒ–',
                    data: rawData,
                    borderColor: 'transparent',
                    backgroundColor: 'rgba(0,0,0,0.05)',
                    fill: true,
                    pointRadius: 0,
                    segment: {
                        backgroundColor: ctx => {
                            const index = ctx.p1DataIndex;
                            const slopeValues = rollingSlope(rawData);
                            const slopeValue = slopeValues[index];
                            if (slopeValue === null || typeof slopeValue === 'undefined') return 'rgba(128, 128, 128, 0.1)';
                            if (slopeValue > 0) return 'rgba(0, 128, 0, 0.2)';
                            if (slopeValue < 0) return 'rgba(255, 0, 0, 0.2)';
                            return 'rgba(128, 128, 128, 0.2)';
                        }
                    },
                    hidden: false,
                    order: 4
                },
                {
                    label: 'åŸå§‹è³‡æ–™',
                    data: rawData,
                    borderColor: 'blue',
                    backgroundColor: 'rgba(0, 0, 255, 0.1)',
                    fill: false,
                    hidden: false,
                    order: 1
                },
                {
                    label: '7æ—¥ç§»å‹•å¹³å‡',
                    data: movingAverage(rawData),
                    borderColor: 'orange',
                    backgroundColor: 'rgba(255, 165, 0, 0.1)',
                    fill: false,
                    hidden: false,
                    order: 2
                },
                {
                    label: '7æ—¥å±€éƒ¨æ–œç‡',
                    data: rollingSlope(rawData),
                    borderColor: 'gray',
                    fill: false,
                    hidden: false,
                    segment: {
                        borderColor: ctx => {
                            const value = ctx.p1.parsed.y;
                            if (value === null || typeof value === 'undefined') return 'rgba(128, 128, 128, 0.5)';
                            if (value > 0) return 'green';
                            if (value < 0) return 'red';
                            return 'gray';
                        }
                    },
                    borderWidth: 2,
                    pointRadius: 3,
                    order: 3,
                    yAxisID: 'ySlope'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'æœ‰æ•ˆè™•æ–¹ç­†æ•¸' },
                    position: 'left',
                },
                ySlope: {
                    title: { display: true, text: '7æ—¥å±€éƒ¨æ–œç‡å€¼' },
                    position: 'right',
                    grid: { drawOnChartArea: false }
                },
                x: {
                    title: { display: true, text: 'æ—¥æœŸ' }
                }
            },
            plugins: {
                legend: { display: true },
                tooltip: { mode: 'index', intersect: false }
            }
        }
    });
} else {
    console.error('Canvas context not found');
}

// --- Filtering Logic ---
async function applyFilters() {
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const completedPidsListDiv = document.getElementById('completed-pids-list');
    const completedPidsErrorDiv = document.getElementById('completed-pids-error');
    const calendarTableBody = document.getElementById('calendar-table-body');

    const startDateValue = startDateInput.value;
    const endDateValue = endDateInput.value;

    // --- 1. Fetch Completed Prescriptions --- 
    completedPidsListDiv.innerHTML = 'æŸ¥è©¢ä¸­...';
    completedPidsErrorDiv.style.display = 'none';
    completedPidsErrorDiv.textContent = '';

    if (!startDateValue || !endDateValue) {
        completedPidsListDiv.textContent = 'è«‹é¸æ“‡èµ·å§‹å’ŒçµæŸæ—¥æœŸã€‚';
        return;
    }

    try {
        // The API endpoint will be part of the main application, so the path might need adjustment.
        // For now, assuming it will be '/api/completed-prescriptions' relative to the main app's root.
        const response = await fetch(`/prescriptionChart/api/completed-prescriptions?startDate=${startDateValue}&endDate=${endDateValue}`);
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        const results = data.completedPrescriptions;

        if (results && results.length > 0) {
            let tableHTML = '<table border="1"><thead><tr><th>PID</th><th>çµæŸæ—¥æœŸ</th></tr></thead><tbody>';
            results.forEach(item => {
                tableHTML += `<tr><td>${item.pid}</td><td>${item.endDate}</td></tr>`;
            });
            tableHTML += '</tbody></table>';
            completedPidsListDiv.innerHTML = tableHTML;
        } else {
            completedPidsListDiv.textContent = 'åœ¨æ­¤æœŸé–“å…§ç„¡ç¬¦åˆæ¢ä»¶çš„è™•æ–¹åˆ°æœŸã€‚';
        }
    } catch (error) {
        console.error('Error fetching completed PIDs:', error);
        completedPidsListDiv.textContent = 'æŸ¥è©¢å¤±æ•—ã€‚';
        completedPidsErrorDiv.textContent = `éŒ¯èª¤: ${error.message}`;
        completedPidsErrorDiv.style.display = 'block';
    }

    // --- 2. Filter Chart and Calendar Table Data (Client-Side) ---
    const start = new Date(startDateValue + 'T00:00:00Z');
    const end = new Date(endDateValue + 'T23:59:59Z');

    const filteredCalendar = calendarData.filter(entry => {
        const current = new Date(entry.date + 'T00:00:00Z');
        return (!isNaN(start) ? current >= start : true) &&
               (!isNaN(end) ? current <= end : true);
    });

    const newLabels = filteredCalendar.map(entry => entry.date);
    const newRawData = filteredCalendar.map(entry => entry.count);

    // Update Chart
    if (chart) {
        chart.data.labels = newLabels;
        chart.data.datasets.forEach(dataset => {
            if (dataset.label === 'åŸå§‹è³‡æ–™' || dataset.label === 'å€åŸŸé¡è‰²ä¾æ–œç‡è®ŠåŒ–') {
                dataset.data = newRawData;
            }
            if (dataset.label === '7æ—¥ç§»å‹•å¹³å‡') {
                 dataset.data = movingAverage(newRawData);
            }
            if (dataset.label === '7æ—¥å±€éƒ¨æ–œç‡') {
                 dataset.data = rollingSlope(newRawData);
            }
        });
        chart.update();
    } else {
         console.error("Chart object not available for update.");
    }

    // Update Calendar Table
    calendarTableBody.innerHTML = '';
    if (filteredCalendar.length > 0) {
        filteredCalendar.forEach(entry => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${entry.date}</td><td>${entry.count}</td>`;
            calendarTableBody.appendChild(row);
        });
    } else {
        const row = document.createElement('tr');
        row.innerHTML = `<td colspan="2">ç¯©é¸ç¯„åœå…§ç„¡è³‡æ–™ã€‚</td>`;
        calendarTableBody.appendChild(row);
    }
}

// --- Initial Setup ---
window.addEventListener('DOMContentLoaded', () => {
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');

    if (calendarData && calendarData.length > 0) {
        // Ensure calendarData is sorted by date to get the earliest date for the start input
        const sortedCalendarData = [...calendarData].sort((a, b) => new Date(a.date) - new Date(b.date));
        if (sortedCalendarData.length > 0) {
             startDateInput.value = sortedCalendarData[0].date;
        }
    } else {
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 30); // Default to 30 days ago if no data
        startDateInput.value = yesterday.toISOString().split('T')[0];
    }
    endDateInput.value = new Date().toISOString().split('T')[0];

    // applyFilters(); // Optional: Uncomment to automatically filter on load
});

</script>
</body>
</html>
